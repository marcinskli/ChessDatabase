import cs50
import re
import settings

game_info_re_dict = {
    'white_elo': re.compile(r'\[WhiteElo "(?P<white_elo>\d+)"\]'),
    'black_elo': re.compile(r'\[BlackElo "(?P<black_elo>\d+)"\]'),
    'result': re.compile(r'\[Result "(?P<result>.*)"\]'),
    'ECO': re.compile(r'\[ECO "(?P<ECO>[A-E]\d{2,})"\]'),
    'FEN': re.compile(r'\[FEN "(?P<FEN>.*)"\]'),
}


def get_user_settings():
    while True:
        user_min_elo = cs50.get_int('Minimum average ELO in games you want to get? (0-3000)\n')
        if user_min_elo not in range(3000):
            user_min_elo = 0
            print(f'Value not in range (0-3000). Min ELO changed to {user_min_elo}')
        user_min_moves = cs50.get_int('Minimum number of moves in games you want to get?\n')
        if user_min_moves not in range(300):
            user_min_moves = 0
            print(f'Value not in range (0-300). Min moves changed to {user_min_moves}')
        user_confirmation = cs50.get_string(f'Minimum Average ELO: {user_min_elo}\n'
                                            f'Minimum moves: {user_min_moves}\n'
                                            f'Are you sure? [y/n]\n')
        if user_confirmation.lower() in ['y', 't', 'yes', 'tak']:
            settings.min_elo = user_min_elo
            settings.min_moves = user_min_moves
            break


def import_games(file):
    """

    :param file: imported database
    :return: list = [game_info1, notation1, game_info2, notation2, game_info3, ...]
    """
    with open(file, 'r', errors='ignore') as file:
        imported_games = file.read()

    imported_games.strip()
    list_info_games = re.split("\n\n", imported_games)

    # Deleting empty item at the end of the list
    if list_info_games[-1] == '' or list_info_games[-1] == '\n':
        del list_info_games[-1]

    return list_info_games


class Game:

    def __init__(self, info, notation):
        self.info = info
        self.notation = notation
        # bool info about the game
        self.is_too_short = False
        self.is_low_rated = False
        self.is_fisher = False
        self.is_result_incorrect = False

        self.important_info = {}  # stores information generated by methods

        self.get_game_info()  # filters self.info using regex
        self.get_game_length()
        self.calculate_ratings()
        self.flag_game_info()  # uses information to update bool info

    def show_game(self):
        """

        :return: game in PGN format
        """
        full_game = f'{self.info}\n\n{self.notation}\n\n'
        return full_game

    def get_game_info(self) -> dict:
        """
        Filtering self.info line by line using regex dictionary for information that will be analyzed later.
        :return:
        """
        game_info = re.split('\n', self.info)
        for information in game_info:
            for info, regex in game_info_re_dict.items():
                match = regex.search(information)
                if match:
                    self.important_info[info] = match.group(info)

        return self.important_info

    def get_game_length(self):
        """
        Finds all move numbers in notation and returns the last one.
        If there were no moves in game, return 0.
        """
        try:
            matches = re.compile(r'\d{1,3}\.').findall(self.notation)
            game_length = int(matches[-1].replace('.', ''))
            self.important_info['moves'] = game_length
        except IndexError:
            game_length = 0
            self.important_info['moves'] = game_length

        return game_length

    def calculate_ratings(self):
        try:
            white_elo = int(self.important_info['white_elo'])
            self.important_info['white_elo'] = white_elo
        except KeyError:
            white_elo = 0
        try:
            black_elo = int(self.important_info['black_elo'])
            self.important_info['black_elo'] = black_elo
        except KeyError:
            black_elo = 0

        if white_elo and black_elo:
            avg_elo = (white_elo + black_elo) / 2
        else:
            avg_elo = white_elo + black_elo

        self.important_info['avg_elo'] = avg_elo

        return white_elo, black_elo, avg_elo

    def flag_game_info(self):
        if self.important_info['moves'] < settings.min_moves:
            self.is_too_short = True
        if self.important_info['avg_elo'] < settings.min_elo:
            self.is_low_rated = True
        if self.important_info['result'] not in ['1-0', '0-1', '1/2-1/2']:
            self.is_result_incorrect = True
        try:
            if self.important_info['FEN']:
                self.is_fisher = True
        except KeyError:
            pass


class Database:
    """
    Creates instances of games.
    Creates lists with filtered games.
    Exports lists with games into dedicated files.
    """

    def __init__(self, imported_data, database_name):
        self.imported_data = imported_data
        self.database_name = database_name

        # List for imported games
        self.games = []
        # Lists for filtered games
        self.too_short_games = []
        self.low_rated_games = []
        self.incorrect_result = []
        self.fisher_games = []
        self.filtered_games = []

        self.add_games()
        self.filter_games()
        self.export_games()
        print(self.generate_export_message())

    def add_games(self):
        while self.imported_data:
            try:
                self.games.append(Game(info=self.imported_data.pop(0), notation=self.imported_data.pop(0)))
            # If there is a problem with creating Game() we add info about the place of problem and database,
            # into dictionary place_with_problem.
            except KeyError:
                place_with_problem[self.games[-1].show_game()] = f'KeyError: {self.database_name}.'
            except IndexError:
                place_with_problem[self.games[-1].show_game()] = f'IndexError: {self.database_name}.'
        return self.games

    def filter_games(self):
        for game in self.games:
            if game.is_too_short:
                self.too_short_games.append(game)
            if game.is_low_rated:
                self.low_rated_games.append(game)
            if game.is_fisher:
                self.fisher_games.append(game)
            if game.is_result_incorrect:
                self.incorrect_result.append(game)
            if not (game.is_too_short or game.is_low_rated or game.is_fisher or game.is_result_incorrect):
                self.filtered_games.append(game)

    def export_games(self):
        with open(settings.filtered_database, 'a') as fd:
            for game in self.filtered_games:
                fd.write(game.show_game())
        with open(settings.database_low_rated, 'a') as dlr:
            for game in self.low_rated_games:
                dlr.write(game.show_game())
        with open(settings.database_too_short, 'a') as dts:
            for game in self.too_short_games:
                dts.write(game.show_game())
        with open(settings.database_incorrect_result, 'a') as ir:
            for game in self.incorrect_result:
                ir.write(game.show_game())
        with open(settings.database_chess960, 'a') as chess960:
            for game in self.fisher_games:
                chess960.write(game.show_game())

    def generate_export_message(self):
        filter_export_msg = f'Imported {len(self.games)} games from {self.database_name}.\n'
        filter_export_msg += f'{len(self.filtered_games)} games matching your requirements.\n'
        filter_export_msg += f'{len(self.too_short_games)} games had less than {settings.min_moves} moves.\n'
        filter_export_msg += f'{len(self.low_rated_games)} games had less than {settings.min_elo} ELO average.\n'
        filter_export_msg += f'{len(self.incorrect_result)} games had incorrect result.\n'
        filter_export_msg += f'{len(self.fisher_games)} Fisher games (chess 960).\n'
        filter_export_msg += f'-----\n{self.database_name} (hopefully) exported with success! :)\n-----'

        return filter_export_msg


# Dictionary for collecting data about problems with creating Game()
place_with_problem = {}


def main():
    """
    Main loop there we create new Database.
    """
    get_user_settings()
    # Database(imported_data=import_games(file=settings.database_to_filter), database_name=settings.database_to_filter)
    # Database(imported_data=import_games(file=f'twic_databases\\twic943.pgn'), database_name='twic943')
    for base in range(920, 1368):
        Database(imported_data=import_games(file=f'twic_databases\\twic{base}.pgn'), database_name=f'twic{base}.pgn')

    # Print problems with creating instances of Game()
    for notation, error_base in place_with_problem.items():
        print(f'{error_base}\n{notation}')


if __name__ == "__main__":
    main()
