import re
import settings

game_info_re_dict = {
    'whiteElo': re.compile(r'\[WhiteElo "(?P<whiteElo>\d+)"\]'),
    'blackElo': re.compile(r'\[BlackElo "(?P<blackElo>\d+)"\]'),
    'result': re.compile(r'\[Result "(?P<result>.*)"\]'),
    'ECO': re.compile(r'\[ECO "(?P<ECO>[A-E]\d{2,})"\]'),
    'FEN': re.compile(r'\[FEN "(?P<FEN>.*)"\]'),
}


def import_games(file):
    """

    :param file: imported database
    :return: list = [game_info1, notation1, game_info2, notation2, game_info3, ...]
    """
    with open(file, 'r', errors='ignore') as file:
        imported_games = file.read()

    imported_games.strip()
    list_info_games = re.split("\n\n", imported_games)

    # Deleting empty item at the end of the list
    if list_info_games[-1] == '' or list_info_games[-1] == '\n':
        del list_info_games[-1]

    return list_info_games


class Game:

    def __init__(self, info, notation):
        self.info = info
        self.notation = notation
        # bool info about the game
        self.is_too_short = False
        self.is_low_rated = False
        self.is_fisher = False
        self.is_result_incorrect = False

        self.important_info = {}  # stores information generated by methods

        self.get_game_info()  # filters self.info using regex
        self.get_game_length()
        self.calculate_ratings()
        self.flag_game_info()  # uses information to update bool info

    def show_game(self):
        """

        :return: game in PGN format
        """
        full_game = f'{self.info}\n\n{self.notation}\n\n'
        return full_game

    def get_game_info(self) -> dict:
        """
        Filtering self.info line by line using regex dictionary for information that will be analyzed later.
        :return:
        """
        game_info = re.split('\n', self.info)
        for information in game_info:
            for info, regex in game_info_re_dict.items():
                match = regex.search(information)
                if match:
                    self.important_info[info] = match.group(info)

        return self.important_info

    def get_game_length(self):
        """
        Finds all move numbers in notation and returns the last one.
        If there were no moves in game, return 0.
        """
        try:
            matches = re.compile(r'\d{1,3}\.').findall(self.notation)
            game_length = int(matches[-1].replace('.', ''))
            self.important_info['moves'] = game_length
        except:
            game_length = 0
            self.important_info['moves'] = game_length

        return game_length

    def calculate_ratings(self):
        try:
            whiteElo = int(self.important_info['whiteElo'])
            self.important_info['whiteElo'] = whiteElo
        except:
            whiteElo = 0
        try:
            blackElo = int(self.important_info['blackElo'])
            self.important_info['blackElo'] = blackElo
        except:
            blackElo = 0

        if whiteElo and blackElo:
            avgElo = (whiteElo + blackElo) / 2
        else:
            avgElo = whiteElo + blackElo

        self.important_info['avgElo'] = avgElo

        return whiteElo, blackElo, avgElo

    def flag_game_info(self):
        if self.important_info['moves'] < settings.minMoves:
            self.is_too_short = True
        if self.important_info['avgElo'] < settings.minElo:
            self.is_low_rated = True
        if self.important_info['result'] not in ['1-0', '0-1', '1/2-1/2']:
            self.is_result_incorrect = True
        try:
            if self.important_info['FEN']:
                self.is_fisher = True
        except:
            pass


class Database:
    """
    Creates instances of games.
    Creates lists with filtered games.
    Exports lists with games into dedicated files.
    """
    def __init__(self, imported_data, database_name):
        self.imported_data = imported_data
        self.database_name = database_name

        # List for imported games
        self.games = []
        # Lists for filtered games
        self.too_short_games = []
        self.low_rated_games = []
        self.incorrect_result = []
        self.fisher_games = []
        self.filtered_games = []

        self.add_games()
        self.filter_games()
        self.export_games()
        print(self.generate_export_message())

    def add_games(self):
        while self.imported_data:
            try:
                self.games.append(Game(info=self.imported_data.pop(0), notation=self.imported_data.pop(0)))
            # If there is a problem with creating Game() we add info about the place of problem and database,
            # into dictionary place_with_problem.
            except KeyError:
                place_with_problem[self.games[-1].show_game()] = f'KeyError: {self.database_name}.'
            except IndexError:
                place_with_problem[self.games[-1].show_game()] = f'IndexError: {self.database_name}.'
        return self.games

    def filter_games(self):
        for game in self.games:
            if game.is_too_short:
                self.too_short_games.append(game)
            if game.is_low_rated:
                self.low_rated_games.append(game)
            if game.is_fisher:
                self.fisher_games.append(game)
            if game.is_result_incorrect:
                self.incorrect_result.append(game)
            if not (game.is_too_short or game.is_low_rated or game.is_fisher or game.is_result_incorrect):
                self.filtered_games.append(game)

    def export_games(self):
        with open(settings.filtered_database, 'a') as fd:
            for game in self.filtered_games:
                fd.write(game.show_game())
        with open(settings.database_low_rated, 'a') as lrd:
            for game in self.low_rated_games:
                lrd.write(game.show_game())
        with open(settings.database_too_short, 'a') as tsg:
            for game in self.too_short_games:
                tsg.write(game.show_game())
        with open(settings.database_incorrect_result, 'a') as tsg:
            for game in self.incorrect_result:
                tsg.write(game.show_game())
        with open(settings.database_chess960, 'a') as chess960:
            for game in self.fisher_games:
                chess960.write(game.show_game())

    def generate_export_message(self):
        filter_export_msg = f'Imported {len(self.games)} games from {self.database_name}.\n'
        filter_export_msg += f'There were {len(self.filtered_games)} games matching your requirements.\n'
        filter_export_msg += f'{len(self.too_short_games)} games had less than {settings.minMoves} moves.\n'
        filter_export_msg += f'{len(self.low_rated_games)} games had less than {settings.minElo} ELO average.\n'
        filter_export_msg += f'{len(self.incorrect_result)} games had incorrect result.\n'
        filter_export_msg += f'There were {len(self.fisher_games)} Fisher games (chess 960).\n'
        filter_export_msg += f'\n-----\n{self.database_name} (hopefully) exported successfully! :)\n-----\n'

        return filter_export_msg


place_with_problem = {}


def main():
    """
    Main loop there we create new Database.
    """
    # Database(imported_data=import_games(file=settings.database_to_filter), database_name=settings.database_to_filter)
    # Database(imported_data=import_games(file=f'twic_databases\\twic943.pgn'), database_name='twic943')
    for base in range(920, 1368):
        Database(imported_data=import_games(file=f'twic_databases\\twic{base}.pgn'), database_name='twic{base}.pgn')

    # Print problems with creating instances of Game()
    for notation, error_base in place_with_problem.items():
        print(f'{error_base}\n{notation}')


if __name__ == "__main__":
    main()
